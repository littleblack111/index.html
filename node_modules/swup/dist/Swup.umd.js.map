{"version":3,"file":"Swup.umd.js","sources":["../node_modules/delegate-it/delegate.js","../src/helpers/classify.ts","../src/helpers/getCurrentUrl.ts","../src/helpers/history.ts","../src/helpers/delegateEvent.ts","../src/helpers/Location.ts","../src/modules/fetchPage.ts","../src/modules/Cache.ts","../src/utils/index.ts","../src/modules/Classes.ts","../src/modules/Visit.ts","../src/modules/Hooks.ts","../src/modules/getAnchorElement.ts","../src/modules/awaitAnimations.ts","../src/modules/navigate.ts","../src/modules/animatePageOut.ts","../src/modules/replaceContent.ts","../src/modules/scrollToContent.ts","../src/modules/animatePageIn.ts","../src/modules/renderPage.ts","../src/modules/plugins.ts","../src/modules/resolveUrl.ts","../src/Swup.ts"],"sourcesContent":["/** Keeps track of raw listeners added to the base elements to avoid duplication */\nconst ledger = new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n    if (!wanted && !ledger.has(baseElement)) {\n        return false;\n    }\n    const elementMap = ledger.get(baseElement)\n        ?? new WeakMap();\n    ledger.set(baseElement, elementMap);\n    const setups = elementMap.get(callback) ?? new Set();\n    elementMap.set(callback, setups);\n    const existed = setups.has(setup);\n    if (wanted) {\n        setups.add(setup);\n    }\n    else {\n        setups.delete(setup);\n    }\n    return existed && wanted;\n}\nfunction safeClosest(event, selector) {\n    let target = event.target;\n    if (target instanceof Text) {\n        target = target.parentElement;\n    }\n    if (target instanceof Element && event.currentTarget instanceof Element) {\n        // `.closest()` may match ancestors of `currentTarget` but we only need its children\n        const closest = target.closest(selector);\n        if (closest && event.currentTarget.contains(closest)) {\n            return closest;\n        }\n    }\n}\n// This type isn't exported as a declaration, so it needs to be duplicated above\nfunction delegate(selector, type, callback, options = {}) {\n    const { signal, base = document } = options;\n    if (signal?.aborted) {\n        return;\n    }\n    // Don't pass `once` to `addEventListener` because it needs to be handled in `delegate-it`\n    const { once, ...nativeListenerOptions } = options;\n    // `document` should never be the base, it's just an easy way to define \"global event listeners\"\n    const baseElement = base instanceof Document ? base.documentElement : base;\n    // Handle the regular Element usage\n    const capture = Boolean(typeof options === 'object' ? options.capture : options);\n    const listenerFunction = (event) => {\n        const delegateTarget = safeClosest(event, String(selector));\n        if (delegateTarget) {\n            const delegateEvent = Object.assign(event, { delegateTarget });\n            callback.call(baseElement, delegateEvent);\n            if (once) {\n                baseElement.removeEventListener(type, listenerFunction, nativeListenerOptions);\n                editLedger(false, baseElement, callback, setup);\n            }\n        }\n    };\n    const setup = JSON.stringify({ selector, type, capture });\n    const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n    if (!isAlreadyListening) {\n        baseElement.addEventListener(type, listenerFunction, nativeListenerOptions);\n    }\n    signal?.addEventListener('abort', () => {\n        editLedger(false, baseElement, callback, setup);\n    });\n}\nexport default delegate;\n","/** Turn a string into a slug by lowercasing and replacing whitespace. */\nexport const classify = (text: string, fallback?: string): string => {\n\tconst output = String(text)\n\t\t.toLowerCase()\n\t\t// .normalize('NFD') // split an accented letter in the base letter and the acent\n\t\t// .replace(/[\\u0300-\\u036f]/g, '') // remove all previously split accents\n\t\t.replace(/[\\s/_.]+/g, '-') // replace spaces and _./ with '-'\n\t\t.replace(/[^\\w-]+/g, '') // remove all non-word chars\n\t\t.replace(/--+/g, '-') // replace repeating '-' with single '-'\n\t\t.replace(/^-+|-+$/g, ''); // trim '-' from edges\n\treturn output || fallback || '';\n};\n","/** Get the current page URL: path name + query params. Optionally including hash. */\nexport const getCurrentUrl = ({ hash }: { hash?: boolean } = {}): string => {\n\treturn window.location.pathname + window.location.search + (hash ? window.location.hash : '');\n};\n","import { getCurrentUrl } from './getCurrentUrl.js';\n\nexport interface HistoryState {\n\turl: string;\n\tsource: 'swup';\n\trandom: number;\n\tindex?: number;\n\t[key: string]: unknown;\n}\n\ntype HistoryData = Record<string, unknown>;\n\n/** Create a new history record with a custom swup identifier. */\nexport const createHistoryRecord = (url: string, data: HistoryData = {}): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst state: HistoryState = {\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...data\n\t};\n\twindow.history.pushState(state, '', url);\n};\n\n/** Update the current history record with a custom swup identifier. */\nexport const updateHistoryRecord = (url: string | null = null, data: HistoryData = {}): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst currentState = (window.history.state as HistoryState) || {};\n\tconst state: HistoryState = {\n\t\t...currentState,\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...data\n\t};\n\twindow.history.replaceState(state, '', url);\n};\n","import delegate, {\n\ttype DelegateEventHandler,\n\ttype DelegateOptions,\n\ttype EventType\n} from 'delegate-it';\nimport type { ParseSelector } from 'typed-query-selector/parser.js';\n\nexport type DelegateEventUnsubscribe = {\n\tdestroy: () => void;\n};\n\n/** Register a delegated event listener. */\nexport const delegateEvent = <\n\tSelector extends string,\n\tTElement extends Element = ParseSelector<Selector, HTMLElement>,\n\tTEvent extends EventType = EventType\n>(\n\tselector: Selector,\n\ttype: TEvent,\n\tcallback: DelegateEventHandler<GlobalEventHandlersEventMap[TEvent], TElement>,\n\toptions?: DelegateOptions\n): DelegateEventUnsubscribe => {\n\tconst controller = new AbortController();\n\toptions = { ...options, signal: controller.signal };\n\tdelegate<Selector, TElement, TEvent>(selector, type, callback, options);\n\treturn { destroy: () => controller.abort() };\n};\n","/**\n * A helper for creating a Location from either an element\n * or a URL object/string\n *\n */\nexport class Location extends URL {\n\tconstructor(url: URL | string, base: string = document.baseURI) {\n\t\tsuper(url.toString(), base);\n\t\t// Fix Safari bug with extending native classes\n\t\tObject.setPrototypeOf(this, Location.prototype);\n\t}\n\n\t/**\n\t * The full local path including query params.\n\t */\n\tget url(): string {\n\t\treturn this.pathname + this.search;\n\t}\n\n\t/**\n\t * Instantiate a Location from an element's href attribute\n\t * @param el\n\t * @returns new Location instance\n\t */\n\tstatic fromElement(el: Element): Location {\n\t\tconst href = el.getAttribute('href') || el.getAttribute('xlink:href') || '';\n\t\treturn new Location(href);\n\t}\n\n\t/**\n\t * Instantiate a Location from a URL object or string\n\t * @param url\n\t * @returns new Location instance\n\t */\n\tstatic fromUrl(url: URL | string): Location {\n\t\treturn new Location(url);\n\t}\n}\n","import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport type { Visit } from './Visit.js';\n\n/** A page object as used by swup and its cache. */\nexport interface PageData {\n\t/** The URL of the page */\n\turl: string;\n\t/** The complete HTML response received from the server */\n\thtml: string;\n}\n\n/** Define how a page is fetched. */\nexport interface FetchOptions extends Omit<RequestInit, 'cache'> {\n\t/** The request method. */\n\tmethod?: 'GET' | 'POST';\n\t/** The body of the request: raw string, form data object or URL params. */\n\tbody?: string | FormData | URLSearchParams;\n\t/** The request timeout in milliseconds. */\n\ttimeout?: number;\n\t/** Optional visit object with additional context. @internal */\n\tvisit?: Visit;\n}\n\nexport class FetchError extends Error {\n\turl: string;\n\tstatus?: number;\n\taborted: boolean;\n\ttimedOut: boolean;\n\tconstructor(\n\t\tmessage: string,\n\t\tdetails: { url: string; status?: number; aborted?: boolean; timedOut?: boolean }\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'FetchError';\n\t\tthis.url = details.url;\n\t\tthis.status = details.status;\n\t\tthis.aborted = details.aborted || false;\n\t\tthis.timedOut = details.timedOut || false;\n\t}\n}\n\n/**\n * Fetch a page from the server, return it and cache it.\n */\nexport async function fetchPage(\n\tthis: Swup,\n\turl: URL | string,\n\toptions: FetchOptions = {}\n): Promise<PageData> {\n\turl = Location.fromUrl(url).url;\n\n\tconst { visit = this.visit } = options;\n\tconst headers = { ...this.options.requestHeaders, ...options.headers };\n\tconst timeout = options.timeout ?? this.options.timeout;\n\tconst controller = new AbortController();\n\tconst { signal } = controller;\n\toptions = { ...options, headers, signal };\n\n\tlet timedOut = false;\n\tlet timeoutId: ReturnType<typeof setTimeout> | null = null;\n\tif (timeout && timeout > 0) {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimedOut = true;\n\t\t\tcontroller.abort('timeout');\n\t\t}, timeout);\n\t}\n\n\t// Allow hooking before this and returning a custom response-like object (e.g. custom fetch implementation)\n\tlet response: Response;\n\ttry {\n\t\tresponse = await this.hooks.call(\n\t\t\t'fetch:request',\n\t\t\tvisit,\n\t\t\t{ url, options },\n\t\t\t(visit, { url, options }) => fetch(url, options)\n\t\t);\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t} catch (error) {\n\t\tif (timedOut) {\n\t\t\tthis.hooks.call('fetch:timeout', visit, { url });\n\t\t\tthrow new FetchError(`Request timed out: ${url}`, { url, timedOut });\n\t\t}\n\t\tif ((error as Error)?.name === 'AbortError' || signal.aborted) {\n\t\t\tthrow new FetchError(`Request aborted: ${url}`, { url, aborted: true });\n\t\t}\n\t\tthrow error;\n\t}\n\n\tconst { status, url: responseUrl } = response;\n\tconst html = await response.text();\n\n\tif (status === 500) {\n\t\tthis.hooks.call('fetch:error', visit, { status, response, url: responseUrl });\n\t\tthrow new FetchError(`Server error: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\tif (!html) {\n\t\tthrow new FetchError(`Empty response: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\t// Resolve real url after potential redirect\n\tconst { url: finalUrl } = Location.fromUrl(responseUrl);\n\tconst page = { url: finalUrl, html };\n\n\t// Write to cache for safe methods and non-redirects\n\tif (visit.cache.write && (!options.method || options.method === 'GET') && url === finalUrl) {\n\t\tthis.cache.set(page.url, page);\n\t}\n\n\treturn page;\n}\n","import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport { type PageData } from './fetchPage.js';\n\nexport interface CacheData extends PageData {}\n\n/**\n * In-memory page cache.\n */\nexport class Cache {\n\t/** Swup instance this cache belongs to */\n\tprotected swup: Swup;\n\n\t/** Cached pages, indexed by URL */\n\tprotected pages: Map<string, CacheData> = new Map();\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\t/** Number of cached pages in memory. */\n\tget size(): number {\n\t\treturn this.pages.size;\n\t}\n\n\t/** All cached pages. */\n\tget all() {\n\t\tconst copy = new Map();\n\t\tthis.pages.forEach((page, key) => {\n\t\t\tcopy.set(key, { ...page });\n\t\t});\n\t\treturn copy;\n\t}\n\n\t/** Check if the given URL has been cached. */\n\thas(url: string): boolean {\n\t\treturn this.pages.has(this.resolve(url));\n\t}\n\n\t/** Return a shallow copy of the cached page object if available. */\n\tget(url: string): CacheData | undefined {\n\t\tconst result = this.pages.get(this.resolve(url));\n\t\tif (!result) return result;\n\t\treturn { ...result };\n\t}\n\n\t/** Create a cache record for the specified URL. */\n\tset(url: string, page: CacheData) {\n\t\turl = this.resolve(url);\n\t\tpage = { ...page, url };\n\t\tthis.pages.set(url, page);\n\t\tthis.swup.hooks.callSync('cache:set', undefined, { page });\n\t}\n\n\t/** Update a cache record, overwriting or adding custom data. */\n\tupdate(url: string, payload: object) {\n\t\turl = this.resolve(url);\n\t\tconst page = { ...this.get(url), ...payload, url } as CacheData;\n\t\tthis.pages.set(url, page);\n\t}\n\n\t/** Delete a cache record. */\n\tdelete(url: string): void {\n\t\tthis.pages.delete(this.resolve(url));\n\t}\n\n\t/** Empty the cache. */\n\tclear(): void {\n\t\tthis.pages.clear();\n\t\tthis.swup.hooks.callSync('cache:clear', undefined, undefined);\n\t}\n\n\t/** Remove all cache entries that return true for a given predicate function.  */\n\tprune(predicate: (url: string, page: CacheData) => boolean): void {\n\t\tthis.pages.forEach((page, url) => {\n\t\t\tif (predicate(url, page)) {\n\t\t\t\tthis.delete(url);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** Resolve URLs by making them local and letting swup resolve them. */\n\tprotected resolve(urlToResolve: string): string {\n\t\tconst { url } = Location.fromUrl(urlToResolve);\n\t\treturn this.swup.resolveUrl(url);\n\t}\n}\n","/** Find an element by selector. */\nexport const query = (selector: string, context: Document | Element = document) => {\n\treturn context.querySelector<HTMLElement>(selector);\n};\n\n/** Find a set of elements by selector. */\nexport const queryAll = (\n\tselector: string,\n\tcontext: Document | Element = document\n): HTMLElement[] => {\n\treturn Array.from(context.querySelectorAll(selector));\n};\n\n/** Return a Promise that resolves after the next event loop. */\nexport const nextTick = (): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\trequestAnimationFrame(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/** Check if an object is a Promise or a Thenable */\nexport function isPromise<T>(obj: unknown): obj is PromiseLike<T> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === 'object' || typeof obj === 'function') &&\n\t\ttypeof (obj as Record<string, unknown>).then === 'function'\n\t);\n}\n\n/** Call a function as a Promise. Resolves with the returned Promsise or immediately. */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nexport function runAsPromise(func: Function, args: unknown[] = []): Promise<unknown> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst result: unknown = func(...args);\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n}\n\n/**\n * Force a layout reflow, e.g. after adding classnames\n * @see https://stackoverflow.com/a/21665117/3759615\n */\nexport function forceReflow(element?: HTMLElement): void {\n\telement = element || document.body;\n\telement?.getBoundingClientRect();\n}\n\n/**\n * Read data attribute from closest element with that attribute.\n *\n * Returns `undefined` if no element is found or attribute is missing.\n * Returns `true` if attribute is present without a value.\n */\nexport function getContextualAttr(\n\tel: Element | undefined,\n\tattr: string\n): string | boolean | undefined {\n\tconst target = el?.closest(`[${attr}]`);\n\treturn target?.hasAttribute(attr) ? target?.getAttribute(attr) || true : undefined;\n}\n","import type Swup from '../Swup.js';\nimport { queryAll } from '../utils.js';\n\nexport class Classes {\n\tprotected swup: Swup;\n\tprotected swupClasses = [\n\t\t'to-',\n\t\t'is-changing',\n\t\t'is-rendering',\n\t\t'is-popstate',\n\t\t'is-animating',\n\t\t'is-leaving'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\tprotected get selectors(): string[] {\n\t\tconst { scope } = this.swup.visit.animation;\n\t\tif (scope === 'containers') return this.swup.visit.containers;\n\t\tif (scope === 'html') return ['html'];\n\t\tif (Array.isArray(scope)) return scope;\n\t\treturn [];\n\t}\n\n\tprotected get selector(): string {\n\t\treturn this.selectors.join(',');\n\t}\n\n\tprotected get targets(): HTMLElement[] {\n\t\tif (!this.selector.trim()) return [];\n\t\treturn queryAll(this.selector);\n\t}\n\n\tadd(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.add(...classes));\n\t}\n\n\tremove(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.remove(...classes));\n\t}\n\n\tclear(): void {\n\t\tthis.targets.forEach((target) => {\n\t\t\tconst remove = target.className.split(' ').filter((c) => this.isSwupClass(c));\n\t\t\ttarget.classList.remove(...remove);\n\t\t});\n\t}\n\n\tprotected isSwupClass(className: string): boolean {\n\t\treturn this.swupClasses.some((c) => className.startsWith(c));\n\t}\n}\n","import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport type { HistoryAction, HistoryDirection } from './navigate.js';\n\n/** See below for the class Visit {} definition */\n// export interface Visit {}\n\nexport interface VisitFrom {\n\t/** The URL of the previous page */\n\turl: string;\n\t/** The hash of the previous page */\n\thash?: string;\n}\n\nexport interface VisitTo {\n\t/** The URL of the next page */\n\turl: string;\n\t/** The hash of the next page */\n\thash?: string;\n\t/** The HTML content of the next page */\n\thtml?: string;\n\t/** The parsed document of the next page, available during visit */\n\tdocument?: Document;\n}\n\nexport interface VisitAnimation {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate: boolean;\n\t/** Whether to wait for the next page to load before starting the animation. Default: `false` */\n\twait: boolean;\n\t/** Name of a custom animation to run. */\n\tname?: string;\n\t/** Whether this animation uses the native browser ViewTransition API. Default: `false` */\n\tnative: boolean;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tscope: 'html' | 'containers' | string[];\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tselector: Options['animationSelector'];\n}\n\nexport interface VisitScroll {\n\t/** Whether to reset the scroll position after the visit. Default: `true` */\n\treset: boolean;\n\t/** Anchor element to scroll to on the next page. */\n\ttarget?: string | false;\n}\n\nexport interface VisitTrigger {\n\t/** DOM element that triggered this visit. */\n\tel?: Element;\n\t/** DOM event that triggered this visit. */\n\tevent?: Event;\n}\n\nexport interface VisitCache {\n\t/** Whether this visit will try to load the requested page from cache. */\n\tread: boolean;\n\t/** Whether this visit will save the loaded page in cache. */\n\twrite: boolean;\n}\n\nexport interface VisitHistory {\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\taction: HistoryAction;\n\t/** Whether this visit was triggered by a browser history navigation. */\n\tpopstate: boolean;\n\t/** The direction of travel in case of a browser history navigation: backward or forward. */\n\tdirection: HistoryDirection | undefined;\n}\n\nexport interface VisitInitOptions {\n\tto: string;\n\tfrom?: string;\n\thash?: string;\n\tel?: Element;\n\tevent?: Event;\n}\n\n/** @internal */\nexport const VisitState = {\n\tCREATED: 1,\n\tQUEUED: 2,\n\tSTARTED: 3,\n\tLEAVING: 4,\n\tLOADED: 5,\n\tENTERING: 6,\n\tCOMPLETED: 7,\n\tABORTED: 8,\n\tFAILED: 9\n} as const;\n\n/** @internal */\nexport type VisitState = (typeof VisitState)[keyof typeof VisitState];\n\n/** An object holding details about the current visit. */\nexport class Visit {\n\t/** A unique ID to identify this visit */\n\tid: number;\n\t/** The current state of this visit @internal */\n\tstate: VisitState;\n\t/** The previous page, about to leave */\n\tfrom: VisitFrom;\n\t/** The next page, about to enter */\n\tto: VisitTo;\n\t/** The content containers, about to be replaced */\n\tcontainers: Options['containers'];\n\t/** Information about animated page transitions */\n\tanimation: VisitAnimation;\n\t/** What triggered this visit */\n\ttrigger: VisitTrigger;\n\t/** Cache behavior for this visit */\n\tcache: VisitCache;\n\t/** Browser history behavior on this visit */\n\thistory: VisitHistory;\n\t/** Scroll behavior on this visit */\n\tscroll: VisitScroll;\n\t/** User-defined metadata */\n\tmeta: Record<string, unknown>;\n\n\tconstructor(swup: Swup, options: VisitInitOptions) {\n\t\tconst { to, from, hash, el, event } = options;\n\n\t\tthis.id = Math.random();\n\t\tthis.state = VisitState.CREATED;\n\t\tthis.from = { url: from ?? swup.location.url, hash: swup.location.hash };\n\t\tthis.to = { url: to, hash };\n\t\tthis.containers = swup.options.containers;\n\t\tthis.animation = {\n\t\t\tanimate: true,\n\t\t\twait: false,\n\t\t\tname: undefined,\n\t\t\tnative: swup.options.native,\n\t\t\tscope: swup.options.animationScope,\n\t\t\tselector: swup.options.animationSelector\n\t\t};\n\t\tthis.trigger = { el, event };\n\t\tthis.cache = {\n\t\t\tread: swup.options.cache,\n\t\t\twrite: swup.options.cache\n\t\t};\n\t\tthis.history = {\n\t\t\taction: 'push',\n\t\t\tpopstate: false,\n\t\t\tdirection: undefined\n\t\t};\n\t\tthis.scroll = {\n\t\t\treset: true,\n\t\t\ttarget: undefined\n\t\t};\n\t\tthis.meta = {};\n\t}\n\n\t/** @internal */\n\tadvance(state: VisitState) {\n\t\tif (this.state < state) {\n\t\t\tthis.state = state;\n\t\t}\n\t}\n\n\t/** @internal */\n\tabort() {\n\t\tthis.state = VisitState.ABORTED;\n\t}\n\n\t/** Is this visit done, i.e. completed, failed, or aborted? */\n\tget done(): boolean {\n\t\treturn this.state >= VisitState.COMPLETED;\n\t}\n}\n\n/** Create a new visit object. */\nexport function createVisit(this: Swup, options: VisitInitOptions): Visit {\n\treturn new Visit(this, options);\n}\n","import type { DelegateEvent } from 'delegate-it';\n\nimport type Swup from '../Swup.js';\nimport { isPromise, runAsPromise } from '../utils.js';\nimport { Visit } from './Visit.js';\nimport type { FetchOptions, PageData } from './fetchPage.js';\n\nexport interface HookDefinitions {\n\t'animation:out:start': undefined;\n\t'animation:out:await': { skip: boolean };\n\t'animation:out:end': undefined;\n\t'animation:in:start': undefined;\n\t'animation:in:await': { skip: boolean };\n\t'animation:in:end': undefined;\n\t'animation:skip': undefined;\n\t'cache:clear': undefined;\n\t'cache:set': { page: PageData };\n\t'content:replace': { page: PageData };\n\t'content:scroll': undefined;\n\t'enable': undefined;\n\t'disable': undefined;\n\t'fetch:request': { url: string; options: FetchOptions };\n\t'fetch:error': { url: string; status: number; response: Response };\n\t'fetch:timeout': { url: string };\n\t'history:popstate': { event: PopStateEvent };\n\t'link:click': { el: HTMLAnchorElement; event: DelegateEvent<MouseEvent> };\n\t'link:self': undefined;\n\t'link:anchor': { hash: string };\n\t'link:newtab': { href: string };\n\t'page:load': { page?: PageData; cache?: boolean; options: FetchOptions };\n\t'page:view': { url: string; title: string };\n\t'scroll:top': { options: ScrollIntoViewOptions };\n\t'scroll:anchor': { hash: string; options: ScrollIntoViewOptions };\n\t'visit:start': undefined;\n\t'visit:transition': undefined;\n\t'visit:abort': undefined;\n\t'visit:end': undefined;\n}\n\nexport interface HookReturnValues {\n\t'content:scroll': Promise<boolean> | boolean;\n\t'fetch:request': Promise<Response>;\n\t'page:load': Promise<PageData>;\n\t'scroll:top': boolean;\n\t'scroll:anchor': boolean;\n}\n\nexport type HookArguments<T extends HookName> = HookDefinitions[T];\n\nexport type HookName = keyof HookDefinitions;\n\nexport type HookNameWithModifier = `${HookName}.${HookModifier}`;\n\ntype HookModifier = 'once' | 'before' | 'replace';\n\n/** A generic hook handler. */\nexport type HookHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>\n) => Promise<unknown> | unknown;\n\n/** A default hook handler with an expected return type. */\nexport type HookDefaultHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>,\n\t/** Default handler to be executed. Available if replacing an internal hook handler. */\n\tdefaultHandler?: HookDefaultHandler<T>\n) => T extends keyof HookReturnValues ? HookReturnValues[T] : Promise<unknown> | unknown;\n\nexport type Handlers = {\n\t[K in HookName]: HookHandler<K>[];\n};\n\nexport type HookInitOptions = {\n\t[K in HookName as K | `${K}.${HookModifier}`]: HookHandler<K>;\n} & {\n\t[K in HookName as K | `${K}.${HookModifier}.${HookModifier}`]: HookHandler<K>;\n};\n\n/** Unregister a previously registered hook handler. */\nexport type HookUnregister = () => void;\n\n/** Define when and how a hook handler is executed. */\nexport type HookOptions = {\n\t/** Execute the hook once, then remove the handler */\n\tonce?: boolean;\n\t/** Execute the hook before the internal default handler */\n\tbefore?: boolean;\n\t/** Set a priority for when to execute this hook. Lower numbers execute first. Default: `0` */\n\tpriority?: number;\n\t/** Replace the internal default handler with this hook handler */\n\treplace?: boolean;\n};\n\nexport type HookRegistration<\n\tT extends HookName,\n\tH extends HookHandler<T> | HookDefaultHandler<T> = HookHandler<T>\n> = {\n\tid: number;\n\thook: T;\n\thandler: H;\n\tdefaultHandler?: HookDefaultHandler<T>;\n} & HookOptions;\n\ntype HookEventDetail = {\n\thook: HookName;\n\targs: unknown;\n\tvisit: Visit;\n};\n\nexport type HookEvent = CustomEvent<HookEventDetail>;\n\ntype HookLedger<T extends HookName> = Map<HookHandler<T>, HookRegistration<T>>;\n\ninterface HookRegistry extends Map<HookName, HookLedger<HookName>> {\n\tget<K extends HookName>(key: K): HookLedger<K> | undefined;\n\tset<K extends HookName>(key: K, value: HookLedger<K>): this;\n}\n\n/**\n * Hook registry.\n *\n * Create, trigger and handle hooks.\n *\n */\nexport class Hooks {\n\t/** Swup instance this registry belongs to */\n\tprotected swup: Swup;\n\n\t/** Map of all registered hook handlers. */\n\tprotected registry: HookRegistry = new Map();\n\n\t// Can we deduplicate this somehow? Or make it error when not in sync with HookDefinitions?\n\t// https://stackoverflow.com/questions/53387838/how-to-ensure-an-arrays-values-the-keys-of-a-typescript-interface/53395649\n\tprotected readonly hooks: HookName[] = [\n\t\t'animation:out:start',\n\t\t'animation:out:await',\n\t\t'animation:out:end',\n\t\t'animation:in:start',\n\t\t'animation:in:await',\n\t\t'animation:in:end',\n\t\t'animation:skip',\n\t\t'cache:clear',\n\t\t'cache:set',\n\t\t'content:replace',\n\t\t'content:scroll',\n\t\t'enable',\n\t\t'disable',\n\t\t'fetch:request',\n\t\t'fetch:error',\n\t\t'fetch:timeout',\n\t\t'history:popstate',\n\t\t'link:click',\n\t\t'link:self',\n\t\t'link:anchor',\n\t\t'link:newtab',\n\t\t'page:load',\n\t\t'page:view',\n\t\t'scroll:top',\n\t\t'scroll:anchor',\n\t\t'visit:start',\n\t\t'visit:transition',\n\t\t'visit:abort',\n\t\t'visit:end'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Create ledgers for all core hooks.\n\t */\n\tprotected init() {\n\t\tthis.hooks.forEach((hook) => this.create(hook));\n\t}\n\n\t/**\n\t * Create a new hook type.\n\t */\n\tcreate(hook: string) {\n\t\tif (!this.registry.has(hook as HookName)) {\n\t\t\tthis.registry.set(hook as HookName, new Map());\n\t\t}\n\t}\n\n\t/**\n\t * Check if a hook type exists.\n\t */\n\texists(hook: HookName): boolean {\n\t\treturn this.registry.has(hook);\n\t}\n\n\t/**\n\t * Get the ledger with all registrations for a hook.\n\t */\n\tprotected get<T extends HookName>(hook: T): HookLedger<T> | undefined {\n\t\tconst ledger = this.registry.get(hook);\n\t\tif (ledger) {\n\t\t\treturn ledger;\n\t\t}\n\t\tconsole.error(`Unknown hook '${hook}'`);\n\t}\n\n\t/**\n\t * Remove all handlers of all hooks.\n\t */\n\tclear() {\n\t\tthis.registry.forEach((ledger) => ledger.clear());\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Object to specify how and when the handler is executed\n\t *                Available options:\n\t *                - `once`: Only execute the handler once\n\t *                - `before`: Execute the handler before the default handler\n\t *                - `priority`: Specify the order in which the handlers are executed\n\t *                - `replace`: Replace the default handler with this handler\n\t * @returns A function to unregister the handler\n\t */\n\n\t// Overload: replacing default handler\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookDefaultHandler<T>, options: O & { replace: true }): HookUnregister; // prettier-ignore\n\t// Overload: passed in handler options\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookHandler<T>, options: O): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\ton<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\ton<T extends HookName, O extends HookOptions>(\n\t\thook: T,\n\t\thandler: O['replace'] extends true ? HookDefaultHandler<T> : HookHandler<T>,\n\t\toptions: Partial<O> = {}\n\t): HookUnregister {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\tconsole.warn(`Hook '${hook}' not found.`);\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst id = ledger.size + 1;\n\t\tconst registration: HookRegistration<T> = { ...options, id, hook, handler };\n\t\tledger.set(handler, registration);\n\n\t\treturn () => this.off(hook, handler);\n\t}\n\n\t/**\n\t * Register a new hook handler to run before the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { before: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tbefore<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to replace the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { replace: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute instead of the default handler\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\treplace<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookDefaultHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to run once.\n\t * Shortcut for `hooks.on(hook, handler, { once: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tonce<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\t/**\n\t * Unregister a hook handler.\n\t * @param hook Name of the hook the handler is registered for\n\t * @param handler The handler function that was registered.\n\t *                If omitted, all handlers for the hook will be removed.\n\t */\n\t// Overload: unregister a specific handler\n\toff<T extends HookName>(hook: T, handler: HookHandler<T> | HookDefaultHandler<T>): void;\n\t// Overload: unregister all handlers\n\toff<T extends HookName>(hook: T): void;\n\t// Implementation\n\toff<T extends HookName>(hook: T, handler?: HookHandler<T> | HookDefaultHandler<T>): void {\n\t\tconst ledger = this.get(hook);\n\t\tif (ledger && handler) {\n\t\t\tconst deleted = ledger.delete(handler);\n\t\t\tif (!deleted) {\n\t\t\t\tconsole.warn(`Handler for hook '${hook}' not found.`);\n\t\t\t}\n\t\t} else if (ledger) {\n\t\t\tledger.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a hook asynchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order and `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param visit The visit object this hook belongs to\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The resolved return value of the executed default handler\n\t */\n\t// Overload: default order of arguments\n\tasync call<T extends HookName>(hook: T, visit: Visit | undefined, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>>; // prettier-ignore\n\t// Overload: legacy order of arguments, with visit missing\n\tasync call<T extends HookName>(hook: T, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>>; // prettier-ignore\n\t// Implementation\n\tasync call<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T>,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>> {\n\t\tconst [visit, args, defaultHandler] = this.parseCallArgs(hook, arg1, arg2, arg3);\n\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tawait this.run(before, visit, args);\n\t\tconst [result] = await this.run(handler, visit, args, true);\n\t\tawait this.run(after, visit, args);\n\t\tthis.dispatchDomEvent(hook, visit, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Trigger a hook synchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order, but will **not** `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param visit The visit object this hook belongs to\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The (possibly unresolved) return value of the executed default handler\n\t */\n\t// Overload: default order of arguments\n\tcallSync<T extends HookName>(hook: T, visit: Visit | undefined, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): ReturnType<HookDefaultHandler<T>>; // prettier-ignore\n\t// Overload: legacy order of arguments, with visit missing\n\tcallSync<T extends HookName>(hook: T, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): ReturnType<HookDefaultHandler<T>>; // prettier-ignore\n\t// Implementation\n\tcallSync<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T>,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): ReturnType<HookDefaultHandler<T>> {\n\t\tconst [visit, args, defaultHandler] = this.parseCallArgs(hook, arg1, arg2, arg3);\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tthis.runSync(before, visit, args);\n\t\tconst [result] = this.runSync(handler, visit, args, true);\n\t\tthis.runSync(after, visit, args);\n\t\tthis.dispatchDomEvent(hook, visit, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Parse the call arguments for call() and callSync() to allow legacy argument order.\n\t */\n\tprotected parseCallArgs<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T> | undefined,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): [Visit | undefined, HookArguments<T>, HookDefaultHandler<T> | undefined] {\n\t\tconst isLegacyOrder =\n\t\t\t!(arg1 instanceof Visit) && (typeof arg1 === 'object' || typeof arg2 === 'function');\n\t\tif (isLegacyOrder) {\n\t\t\t// Legacy positioning: arguments in second or handler passed in third place\n\t\t\treturn [undefined, arg1 as HookArguments<T>, arg2 as HookDefaultHandler<T>];\n\t\t} else {\n\t\t\t// Default positioning: visit passed in as first argument\n\t\t\treturn [arg1, arg2 as HookArguments<T>, arg3];\n\t\t}\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, as `Promise`s that will be `await`ed.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], visit: Visit | undefined, args: HookArguments<T>, rethrow: true): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>[]>; // prettier-ignore\n\t// Overload:  running user handler: expect no specific type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T>[], visit: Visit | undefined, args: HookArguments<T>): Promise<unknown[]>; // prettier-ignore\n\t// Implementation\n\tprotected async run<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\tvisit: Visit | undefined = this.swup.visit,\n\t\targs: HookArguments<T>,\n\t\trethrow: boolean = false\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>> | unknown[]> {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tif (visit?.done) continue;\n\t\t\tif (once) this.off(hook, handler);\n\t\t\ttry {\n\t\t\t\tconst result = await runAsPromise(handler, [visit, args, defaultHandler]);\n\t\t\t\tresults.push(result);\n\t\t\t} catch (error) {\n\t\t\t\tif (rethrow) {\n\t\t\t\t\tthrow error;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Error in hook '${hook}':`, error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, without `await`ing any returned `Promise`s.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], visit: Visit | undefined, args: HookArguments<T>, rethrow: true): ReturnType<HookDefaultHandler<T>>[]; // prettier-ignore\n\t// Overload: running user handler: expect no specific type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T>[], visit: Visit | undefined, args: HookArguments<T>): unknown[]; // prettier-ignore\n\t// Implementation\n\tprotected runSync<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\tvisit: Visit | undefined = this.swup.visit,\n\t\targs: HookArguments<T>,\n\t\trethrow: boolean = false\n\t): (ReturnType<HookDefaultHandler<T>> | unknown)[] {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tif (visit?.done) continue;\n\t\t\tif (once) this.off(hook, handler);\n\t\t\ttry {\n\t\t\t\tconst result = (handler as HookDefaultHandler<T>)(visit, args, defaultHandler);\n\t\t\t\tresults.push(result);\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Swup will not await Promises in handler for synchronous hook '${hook}'.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (rethrow) {\n\t\t\t\t\tthrow error;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Error in hook '${hook}':`, error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get all registered handlers for a hook, sorted by priority and registration order.\n\t * @param hook Name of the hook\n\t * @param defaultHandler The optional default handler of this hook\n\t * @returns An object with the handlers sorted into `before` and `after` arrays,\n\t *          as well as a flag indicating if the original handler was replaced\n\t */\n\tprotected getHandlers<T extends HookName>(hook: T, defaultHandler?: HookDefaultHandler<T>) {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\treturn { found: false, before: [], handler: [], after: [], replaced: false };\n\t\t}\n\n\t\tconst registrations = Array.from(ledger.values());\n\n\t\t// Let TypeScript know that replaced handlers are default handlers by filtering to true\n\t\tconst def = (T: HookRegistration<T>): T is HookRegistration<T, HookDefaultHandler<T>> => true; // prettier-ignore\n\t\tconst sort = this.sortRegistrations;\n\n\t\t// Filter into before, after, and replace handlers\n\t\tconst before = registrations.filter(({ before, replace }) => before && !replace).sort(sort);\n\t\tconst replace = registrations.filter(({ replace }) => replace).filter(def).sort(sort); // prettier-ignore\n\t\tconst after = registrations.filter(({ before, replace }) => !before && !replace).sort(sort);\n\t\tconst replaced = replace.length > 0;\n\n\t\t// Define main handler registration\n\t\t// Created as HookRegistration[] array to allow passing it into hooks.run() directly\n\t\tlet handler: HookRegistration<T, HookDefaultHandler<T>>[] = [];\n\t\tif (defaultHandler) {\n\t\t\thandler = [{ id: 0, hook, handler: defaultHandler }];\n\t\t\tif (replaced) {\n\t\t\t\tconst index = replace.length - 1;\n\t\t\t\tconst { handler: replacingHandler, once } = replace[index];\n\t\t\t\tconst createDefaultHandler = (index: number): HookDefaultHandler<T> | undefined => {\n\t\t\t\t\tconst next = replace[index - 1];\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\treturn (visit, args) =>\n\t\t\t\t\t\t\tnext.handler(visit, args, createDefaultHandler(index - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn defaultHandler;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst nestedDefaultHandler = createDefaultHandler(index);\n\t\t\t\thandler = [{ id: 0, hook, once, handler: replacingHandler, defaultHandler: nestedDefaultHandler }]; // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\treturn { found: true, before, handler, after, replaced };\n\t}\n\n\t/**\n\t * Sort two hook registrations by priority and registration order.\n\t * @param a The registration object to compare\n\t * @param b The other registration object to compare with\n\t * @returns The sort direction\n\t */\n\tprotected sortRegistrations<T extends HookName>(\n\t\ta: HookRegistration<T>,\n\t\tb: HookRegistration<T>\n\t): number {\n\t\tconst priority = (a.priority ?? 0) - (b.priority ?? 0);\n\t\tconst id = a.id - b.id;\n\t\treturn priority || id || 0;\n\t}\n\n\t/**\n\t * Dispatch a custom event on the `document` for a hook. Prefixed with `swup:`\n\t * @param hook Name of the hook.\n\t */\n\tprotected dispatchDomEvent<T extends HookName>(\n\t\thook: T,\n\t\tvisit: Visit | undefined,\n\t\targs?: HookArguments<T>\n\t): void {\n\t\tif (visit?.done) return;\n\n\t\tconst detail: HookEventDetail = { hook, args, visit: visit || this.swup.visit };\n\t\tdocument.dispatchEvent(\n\t\t\tnew CustomEvent<HookEventDetail>(`swup:any`, { detail, bubbles: true })\n\t\t);\n\t\tdocument.dispatchEvent(\n\t\t\tnew CustomEvent<HookEventDetail>(`swup:${hook}`, { detail, bubbles: true })\n\t\t);\n\t}\n\n\t/**\n\t * Parse a hook name into the name and any modifiers.\n\t * @param hook Name of the hook.\n\t */\n\tparseName(hook: HookName | HookNameWithModifier): [HookName, Partial<HookOptions>] {\n\t\tconst [name, ...modifiers] = hook.split('.');\n\t\tconst options = modifiers.reduce((acc, mod) => ({ ...acc, [mod]: true }), {});\n\t\treturn [name as HookName, options];\n\t}\n}\n","import { query } from '../utils.js';\n\n/**\n * Find the anchor element for a given hash.\n *\n * @param hash Hash with or without leading '#'\n * @returns The element, if found, or null.\n *\n * @see https://html.spec.whatwg.org/#find-a-potential-indicated-element\n */\nexport const getAnchorElement = (hash?: string): Element | null => {\n\tif (hash && hash.charAt(0) === '#') {\n\t\thash = hash.substring(1);\n\t}\n\n\tif (!hash) {\n\t\treturn null;\n\t}\n\n\tconst decoded = decodeURIComponent(hash);\n\tlet element =\n\t\tdocument.getElementById(hash) ||\n\t\tdocument.getElementById(decoded) ||\n\t\tquery(`a[name='${CSS.escape(hash)}']`) ||\n\t\tquery(`a[name='${CSS.escape(decoded)}']`);\n\n\tif (!element && hash === 'top') {\n\t\telement = document.body;\n\t}\n\n\treturn element;\n};\n","import { queryAll } from '../utils.js';\nimport type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n\ntype AnimationType = typeof TRANSITION | typeof ANIMATION;\ntype AnimationEndEvent = `${AnimationType}end`;\ntype AnimationProperty = 'Delay' | 'Duration';\ntype AnimationStyleKey = `${AnimationType}${AnimationProperty}` | 'transitionProperty';\n\nexport type AnimationDirection = 'in' | 'out';\n\n/**\n * Return a Promise that resolves when all CSS animations and transitions\n * are done on the page. Filters by selector or takes elements directly.\n */\nexport async function awaitAnimations(\n\tthis: Swup,\n\t{\n\t\tselector,\n\t\telements\n\t}: {\n\t\tselector: Options['animationSelector'];\n\t\telements?: NodeListOf<HTMLElement> | HTMLElement[];\n\t}\n): Promise<void> {\n\t// Allow usage of swup without animations: { animationSelector: false }\n\tif (selector === false && !elements) {\n\t\treturn;\n\t}\n\n\t// Allow passing in elements\n\tlet animatedElements: HTMLElement[] = [];\n\tif (elements) {\n\t\tanimatedElements = Array.from(elements);\n\t} else if (selector) {\n\t\tanimatedElements = queryAll(selector, document.body);\n\t\t// Warn if no elements match the selector, but keep things going\n\t\tif (!animatedElements.length) {\n\t\t\tconsole.warn(`[swup] No elements found matching animationSelector \\`${selector}\\``);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst awaitedAnimations = animatedElements.map((el) => awaitAnimationsOnElement(el));\n\tconst hasAnimations = awaitedAnimations.filter(Boolean).length > 0;\n\tif (!hasAnimations) {\n\t\tif (selector) {\n\t\t\tconsole.warn(\n\t\t\t\t`[swup] No CSS animation duration defined on elements matching \\`${selector}\\``\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tawait Promise.all(awaitedAnimations);\n}\n\nfunction awaitAnimationsOnElement(element: HTMLElement): Promise<void> | false {\n\tconst { type, timeout, propCount } = getTransitionInfo(element);\n\n\t// Resolve immediately if no transition defined\n\tif (!type || !timeout) {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve) => {\n\t\tconst endEvent: AnimationEndEvent = `${type}end`;\n\t\tconst startTime = performance.now();\n\t\tlet propsTransitioned = 0;\n\n\t\tconst end = () => {\n\t\t\telement.removeEventListener(endEvent, onEnd);\n\t\t\tresolve();\n\t\t};\n\n\t\tconst onEnd = (event: TransitionEvent | AnimationEvent) => {\n\t\t\t// Skip transitions on child elements\n\t\t\tif (event.target !== element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip transitions that happened before we started listening\n\t\t\tconst elapsedTime = (performance.now() - startTime) / 1000;\n\t\t\tif (elapsedTime < event.elapsedTime) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// End if all properties have transitioned\n\t\t\tif (++propsTransitioned >= propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(() => {\n\t\t\tif (propsTransitioned < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\n\t\telement.addEventListener(endEvent, onEnd);\n\t});\n}\n\nfunction getTransitionInfo(element: Element) {\n\tconst styles = window.getComputedStyle(element);\n\n\tconst transitionDelays = getStyleProperties(styles, `${TRANSITION}Delay`);\n\tconst transitionDurations = getStyleProperties(styles, `${TRANSITION}Duration`);\n\tconst transitionTimeout = calculateTimeout(transitionDelays, transitionDurations);\n\n\tconst animationDelays = getStyleProperties(styles, `${ANIMATION}Delay`);\n\tconst animationDurations = getStyleProperties(styles, `${ANIMATION}Duration`);\n\tconst animationTimeout = calculateTimeout(animationDelays, animationDurations);\n\n\tconst timeout = Math.max(transitionTimeout, animationTimeout);\n\tconst type: AnimationType | null =\n\t\ttimeout > 0 ? (transitionTimeout > animationTimeout ? TRANSITION : ANIMATION) : null;\n\tconst propCount = type\n\t\t? type === TRANSITION\n\t\t\t? transitionDurations.length\n\t\t\t: animationDurations.length\n\t\t: 0;\n\n\treturn {\n\t\ttype,\n\t\ttimeout,\n\t\tpropCount\n\t};\n}\n\nexport function getStyleProperties(styles: CSSStyleDeclaration, key: AnimationStyleKey): string[] {\n\treturn (styles[key] || '').split(', ');\n}\n\nexport function calculateTimeout(delays: string[], durations: string[]): number {\n\twhile (delays.length < durations.length) {\n\t\tdelays = delays.concat(delays);\n\t}\n\n\treturn Math.max(...durations.map((duration, i) => toMs(duration) + toMs(delays[i])));\n}\n\nexport function toMs(time: string): number {\n\treturn parseFloat(time) * 1000;\n}\n","import type Swup from '../Swup.js';\nimport { FetchError, type FetchOptions, type PageData } from './fetchPage.js';\nimport { type VisitInitOptions, type Visit, VisitState } from './Visit.js';\nimport { createHistoryRecord, updateHistoryRecord, Location, classify } from '../helpers.js';\nimport { getContextualAttr } from '../utils.js';\n\nexport type HistoryAction = 'push' | 'replace';\nexport type HistoryDirection = 'forwards' | 'backwards';\nexport type NavigationToSelfAction = 'scroll' | 'navigate';\nexport type CacheControl = Partial<{ read: boolean; write: boolean }>;\n\n/** Define how to navigate to a page. */\ntype NavigationOptions = {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate?: boolean;\n\t/** Name of a custom animation to run. */\n\tanimation?: string;\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\thistory?: HistoryAction;\n\t/** Whether this visit should read from or write to the cache. */\n\tcache?: CacheControl;\n\t/** Custom metadata associated with this visit. */\n\tmeta?: Record<string, unknown>;\n};\n\n/**\n * Navigate to a new URL.\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport function navigate(\n\tthis: Swup,\n\turl: string,\n\toptions: NavigationOptions & FetchOptions = {},\n\tinit: Omit<VisitInitOptions, 'to'> = {}\n) {\n\tif (typeof url !== 'string') {\n\t\tthrow new Error(`swup.navigate() requires a URL parameter`);\n\t}\n\n\t// Check if the visit should be ignored\n\tif (this.shouldIgnoreVisit(url, { el: init.el, event: init.event })) {\n\t\twindow.location.assign(url);\n\t\treturn;\n\t}\n\n\tconst { url: to, hash } = Location.fromUrl(url);\n\n\tconst visit = this.createVisit({ ...init, to, hash });\n\tthis.performNavigation(visit, options);\n}\n\n/**\n * Start a visit to a new URL.\n *\n * Internal method that assumes the visit context has already been created.\n *\n * As a user, you should call `swup.navigate(url)` instead.\n *\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport async function performNavigation(\n\tthis: Swup,\n\tvisit: Visit,\n\toptions: NavigationOptions & FetchOptions = {}\n): Promise<void> {\n\tif (this.navigating) {\n\t\tif (this.visit.state >= VisitState.ENTERING) {\n\t\t\t// Currently navigating and content already loaded? Finish and queue\n\t\t\tvisit.state = VisitState.QUEUED;\n\t\t\tthis.onVisitEnd = () => this.performNavigation(visit, options);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Currently navigating and content not loaded? Abort running visit\n\t\t\tawait this.hooks.call('visit:abort', this.visit, undefined);\n\t\t\tdelete this.visit.to.document;\n\t\t\tthis.visit.state = VisitState.ABORTED;\n\t\t}\n\t}\n\n\tthis.navigating = true;\n\tthis.visit = visit;\n\n\tconst { el } = visit.trigger;\n\toptions.referrer = options.referrer || this.location.url;\n\n\tif (options.animate === false) {\n\t\tvisit.animation.animate = false;\n\t}\n\n\t// Clean up old animation classes\n\tif (!visit.animation.animate) {\n\t\tthis.classes.clear();\n\t}\n\n\t// Get history action from option or attribute on trigger element\n\tconst history = options.history || getContextualAttr(el, 'data-swup-history');\n\tif (typeof history === 'string' && ['push', 'replace'].includes(history)) {\n\t\tvisit.history.action = history as HistoryAction;\n\t}\n\n\t// Get custom animation name from option or attribute on trigger element\n\tconst animation = options.animation || getContextualAttr(el, 'data-swup-animation');\n\tif (typeof animation === 'string') {\n\t\tvisit.animation.name = animation;\n\t}\n\n\t// Get custom metadata from option\n\tvisit.meta = options.meta || {};\n\n\t// Sanitize cache option\n\tif (typeof options.cache === 'object') {\n\t\tvisit.cache.read = options.cache.read ?? visit.cache.read;\n\t\tvisit.cache.write = options.cache.write ?? visit.cache.write;\n\t} else if (options.cache !== undefined) {\n\t\tvisit.cache = { read: !!options.cache, write: !!options.cache };\n\t}\n\t// Delete this so that window.fetch doesn't mis-interpret it\n\tdelete options.cache;\n\n\ttry {\n\t\tawait this.hooks.call('visit:start', visit, undefined);\n\n\t\tvisit.state = VisitState.STARTED;\n\n\t\t// Begin loading page\n\t\tconst page = this.hooks.call('page:load', visit, { options }, async (visit, args) => {\n\t\t\t// Read from cache\n\t\t\tlet cachedPage: PageData | undefined;\n\t\t\tif (visit.cache.read) {\n\t\t\t\tcachedPage = this.cache.get(visit.to.url);\n\t\t\t}\n\n\t\t\targs.page = cachedPage || (await this.fetchPage(visit.to.url, args.options));\n\t\t\targs.cache = !!cachedPage;\n\n\t\t\treturn args.page;\n\t\t});\n\n\t\t/**\n\t\t * When the page is loaded: mark the visit as loaded and save\n\t\t * the raw html and a parsed document of the received page in the visit object\n\t\t */\n\t\tpage.then(({ html }) => {\n\t\t\tvisit.advance(VisitState.LOADED);\n\t\t\tvisit.to.html = html;\n\t\t\tvisit.to.document = new DOMParser().parseFromString(html, 'text/html');\n\t\t});\n\n\t\t// Create/update history record if this is not a popstate call or leads to the same URL\n\t\tconst newUrl = visit.to.url + visit.to.hash;\n\t\tif (!visit.history.popstate) {\n\t\t\tif (visit.history.action === 'replace' || visit.to.url === this.location.url) {\n\t\t\t\tupdateHistoryRecord(newUrl);\n\t\t\t} else {\n\t\t\t\tthis.currentHistoryIndex++;\n\t\t\t\tcreateHistoryRecord(newUrl, { index: this.currentHistoryIndex });\n\t\t\t}\n\t\t}\n\t\tthis.location = Location.fromUrl(newUrl);\n\n\t\t// Mark visit type with classes\n\t\tif (visit.history.popstate) {\n\t\t\tthis.classes.add('is-popstate');\n\t\t}\n\t\tif (visit.animation.name) {\n\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t}\n\n\t\t// Wait for page before starting to animate out?\n\t\tif (visit.animation.wait) {\n\t\t\tawait page;\n\t\t}\n\n\t\t// Check if failed/aborted in the meantime\n\t\tif (visit.done) return;\n\n\t\t// Perform the actual transition: animate and replace content\n\t\tawait this.hooks.call('visit:transition', visit, undefined, async () => {\n\t\t\t// No animation? Just await page and render\n\t\t\tif (!visit.animation.animate) {\n\t\t\t\tawait this.hooks.call('animation:skip', undefined);\n\t\t\t\tawait this.renderPage(visit, await page);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Animate page out, render page, animate page in\n\t\t\tvisit.advance(VisitState.LEAVING);\n\t\t\tawait this.animatePageOut(visit);\n\t\t\tif (visit.animation.native && document.startViewTransition) {\n\t\t\t\tawait document.startViewTransition(\n\t\t\t\t\tasync () => await this.renderPage(visit, await page)\n\t\t\t\t).finished;\n\t\t\t} else {\n\t\t\t\tawait this.renderPage(visit, await page);\n\t\t\t}\n\t\t\tawait this.animatePageIn(visit);\n\t\t});\n\n\t\t// Check if failed/aborted in the meantime\n\t\tif (visit.done) return;\n\n\t\t// Finalize visit\n\t\tawait this.hooks.call('visit:end', visit, undefined, () => this.classes.clear());\n\t\tvisit.state = VisitState.COMPLETED;\n\t\tthis.navigating = false;\n\n\t\t/** Run eventually queued function */\n\t\tif (this.onVisitEnd) {\n\t\t\tthis.onVisitEnd();\n\t\t\tthis.onVisitEnd = undefined;\n\t\t}\n\t} catch (error) {\n\t\t// Return early if error is undefined or signals an aborted request\n\t\tif (!error || (error as FetchError)?.aborted) {\n\t\t\tvisit.state = VisitState.ABORTED;\n\t\t\treturn;\n\t\t}\n\n\t\tvisit.state = VisitState.FAILED;\n\n\t\t// Log to console\n\t\tconsole.error(error);\n\n\t\t// Remove current history entry, then load requested url in browser\n\t\tthis.options.skipPopStateHandling = () => {\n\t\t\twindow.location.assign(visit.to.url + visit.to.hash);\n\t\t\treturn true;\n\t\t};\n\n\t\t// Go back to the actual page we're still at\n\t\twindow.history.back();\n\t} finally {\n\t\tdelete visit.to.document;\n\t}\n}\n","import type Swup from '../Swup.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the out/leave animation of the current page.\n * @returns Promise<void>\n */\nexport const animatePageOut = async function (this: Swup, visit: Visit) {\n\tawait this.hooks.call('animation:out:start', visit, undefined, () => {\n\t\tthis.classes.add('is-changing', 'is-animating', 'is-leaving');\n\t});\n\n\tawait this.hooks.call('animation:out:await', visit, { skip: false }, (visit, { skip }) => {\n\t\tif (skip) return;\n\t\treturn this.awaitAnimations({ selector: visit.animation.selector });\n\t});\n\n\tawait this.hooks.call('animation:out:end', visit, undefined);\n};\n","import type Swup from '../Swup.js';\nimport { query, queryAll } from '../utils.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the replacement of content after loading a page.\n *\n * @returns Whether all containers were replaced.\n */\nexport const replaceContent = function (this: Swup, visit: Visit): boolean {\n\tconst incomingDocument = visit.to.document;\n\tif (!incomingDocument) return false;\n\n\t// Update browser title\n\tconst title = incomingDocument.querySelector('title')?.innerText || '';\n\tdocument.title = title;\n\n\t// Save persisted elements\n\tconst persistedElements = queryAll('[data-swup-persist]:not([data-swup-persist=\"\"])');\n\n\t// Update content containers\n\tconst replaced = visit.containers\n\t\t.map((selector) => {\n\t\t\tconst currentEl = document.querySelector(selector);\n\t\t\tconst incomingEl = incomingDocument.querySelector(selector);\n\t\t\tif (currentEl && incomingEl) {\n\t\t\t\tcurrentEl.replaceWith(incomingEl.cloneNode(true));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!currentEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in current document: ${selector}`);\n\t\t\t}\n\t\t\tif (!incomingEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in incoming document: ${selector}`);\n\t\t\t}\n\t\t\treturn false;\n\t\t})\n\t\t.filter(Boolean);\n\n\t// Restore persisted elements\n\tpersistedElements.forEach((existing) => {\n\t\tconst key = existing.getAttribute('data-swup-persist');\n\t\tconst replacement = query(`[data-swup-persist=\"${key}\"]`);\n\t\tif (replacement && replacement !== existing) {\n\t\t\treplacement.replaceWith(existing);\n\t\t}\n\t});\n\n\t// Return true if all containers were replaced\n\treturn replaced.length === visit.containers.length;\n};\n","import type Swup from '../Swup.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Update the scroll position after page render.\n * @returns Promise<boolean>\n */\nexport const scrollToContent = function (this: Swup, visit: Visit): boolean {\n\tconst options: ScrollIntoViewOptions = { behavior: 'auto' };\n\tconst { target, reset } = visit.scroll;\n\tconst scrollTarget = target ?? visit.to.hash;\n\n\tlet scrolled = false;\n\n\tif (scrollTarget) {\n\t\tscrolled = this.hooks.callSync(\n\t\t\t'scroll:anchor',\n\t\t\tvisit,\n\t\t\t{ hash: scrollTarget, options },\n\t\t\t(visit, { hash, options }) => {\n\t\t\t\tconst anchor = this.getAnchorElement(hash);\n\t\t\t\tif (anchor) {\n\t\t\t\t\tanchor.scrollIntoView(options);\n\t\t\t\t}\n\t\t\t\treturn !!anchor;\n\t\t\t}\n\t\t);\n\t}\n\n\tif (reset && !scrolled) {\n\t\tscrolled = this.hooks.callSync('scroll:top', visit, { options }, (visit, { options }) => {\n\t\t\twindow.scrollTo({ top: 0, left: 0, ...options });\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn scrolled;\n};\n","import type Swup from '../Swup.js';\nimport { nextTick } from '../utils.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the in/enter animation of the next page.\n * @returns Promise<void>\n */\nexport const animatePageIn = async function (this: Swup, visit: Visit) {\n\t// Check if failed/aborted in the meantime\n\tif (visit.done) return;\n\n\tconst animation = this.hooks.call(\n\t\t'animation:in:await',\n\t\tvisit,\n\t\t{ skip: false },\n\t\t(visit, { skip }) => {\n\t\t\tif (skip) return;\n\t\t\treturn this.awaitAnimations({ selector: visit.animation.selector });\n\t\t}\n\t);\n\n\tawait nextTick();\n\n\tawait this.hooks.call('animation:in:start', visit, undefined, () => {\n\t\tthis.classes.remove('is-animating');\n\t});\n\n\tawait animation;\n\n\tawait this.hooks.call('animation:in:end', visit, undefined);\n};\n","import { updateHistoryRecord, getCurrentUrl, classify, Location } from '../helpers.js';\nimport type Swup from '../Swup.js';\nimport type { PageData } from './fetchPage.js';\nimport { VisitState, type Visit } from './Visit.js';\n\n/**\n * Render the next page: replace the content and update scroll position.\n */\nexport const renderPage = async function (this: Swup, visit: Visit, page: PageData): Promise<void> {\n\t// Check if failed/aborted in the meantime\n\tif (visit.done) return;\n\n\tvisit.advance(VisitState.ENTERING);\n\n\tconst { url } = page;\n\n\t// update state if the url was redirected\n\tif (!this.isSameResolvedUrl(getCurrentUrl(), url)) {\n\t\tupdateHistoryRecord(url);\n\t\tthis.location = Location.fromUrl(url);\n\t\tvisit.to.url = this.location.url;\n\t\tvisit.to.hash = this.location.hash;\n\t}\n\n\t// replace content: allow handlers and plugins to overwrite paga data and containers\n\tawait this.hooks.call('content:replace', visit, { page }, (visit, { page }) => {\n\t\tthis.classes.remove('is-leaving');\n\t\t// only add for animated page loads\n\t\tif (visit.animation.animate) {\n\t\t\tthis.classes.add('is-rendering');\n\t\t}\n\t\tconst success = this.replaceContent(visit);\n\t\tif (!success) {\n\t\t\tthrow new Error('[swup] Container mismatch, aborting');\n\t\t}\n\t\tif (visit.animation.animate) {\n\t\t\t// Make sure to add these classes to new containers as well\n\t\t\tthis.classes.add('is-changing', 'is-animating', 'is-rendering');\n\t\t\tif (visit.animation.name) {\n\t\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// scroll into view: either anchor or top of page\n\tawait this.hooks.call('content:scroll', visit, undefined, () => {\n\t\treturn this.scrollToContent(visit);\n\t});\n\n\tawait this.hooks.call('page:view', visit, { url: this.location.url, title: document.title });\n};\n","import type Swup from '../Swup.js';\n\nexport type Plugin = {\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true;\n\t/** Name of this plugin */\n\tname: string;\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\t/** The swup instance that mounted this plugin */\n\tswup?: Swup;\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]>;\n\t/** Run on mount */\n\tmount: () => void;\n\t/** Run on unmount */\n\tunmount: () => void;\n\t_beforeMount?: () => void;\n\t_afterUnmount?: () => void;\n\t_checkRequirements?: () => boolean;\n};\n\nconst isSwupPlugin = (maybeInvalidPlugin: unknown): maybeInvalidPlugin is Plugin => {\n\t// @ts-ignore: this might be anything, object or no\n\treturn Boolean(maybeInvalidPlugin?.isSwupPlugin);\n};\n\n/** Install a plugin. */\nexport const use = function (this: Swup, plugin: unknown) {\n\tif (!isSwupPlugin(plugin)) {\n\t\tconsole.error('Not a swup plugin instance', plugin);\n\t\treturn;\n\t}\n\n\tplugin.swup = this;\n\tif (plugin._checkRequirements) {\n\t\tif (!plugin._checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (plugin._beforeMount) {\n\t\tplugin._beforeMount();\n\t}\n\tplugin.mount();\n\n\tthis.plugins.push(plugin);\n\n\treturn this.plugins;\n};\n\n/** Uninstall a plugin. */\nexport function unuse(this: Swup, pluginOrName: Plugin | string) {\n\tconst plugin = this.findPlugin(pluginOrName);\n\tif (!plugin) {\n\t\tconsole.error('No such plugin', plugin);\n\t\treturn;\n\t}\n\n\tplugin.unmount();\n\tif (plugin._afterUnmount) {\n\t\tplugin._afterUnmount();\n\t}\n\n\tthis.plugins = this.plugins.filter((p) => p !== plugin);\n\n\treturn this.plugins;\n}\n\n/** Find a plugin by name or reference. */\nexport function findPlugin(this: Swup, pluginOrName: Plugin | string) {\n\treturn this.plugins.find(\n\t\t(plugin) =>\n\t\t\tplugin === pluginOrName ||\n\t\t\tplugin.name === pluginOrName ||\n\t\t\tplugin.name === `Swup${String(pluginOrName)}`\n\t);\n}\n","import type Swup from '../Swup.js';\n\n/**\n * Utility function to validate and run the global option 'resolveUrl'\n * @param {string} url\n * @returns {string} the resolved url\n */\nexport function resolveUrl(this: Swup, url: string): string {\n\tif (typeof this.options.resolveUrl !== 'function') {\n\t\tconsole.warn(`[swup] options.resolveUrl expects a callback function.`);\n\t\treturn url;\n\t}\n\tconst result = this.options.resolveUrl(url);\n\tif (!result || typeof result !== 'string') {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a url`);\n\t\treturn url;\n\t}\n\tif (result.startsWith('//') || result.startsWith('http')) {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a relative url`);\n\t\treturn url;\n\t}\n\treturn result;\n}\n\n/**\n * Compares the resolved version of two paths and returns true if they are the same\n * @param {string} url1\n * @param {string} url2\n * @returns {boolean}\n */\nexport function isSameResolvedUrl(this: Swup, url1: string, url2: string): boolean {\n\treturn this.resolveUrl(url1) === this.resolveUrl(url2);\n}\n","import { type DelegateEvent } from 'delegate-it';\n\nimport version from './config/version.js';\n\nimport { delegateEvent, getCurrentUrl, Location, updateHistoryRecord } from './helpers.js';\nimport { type DelegateEventUnsubscribe } from './helpers/delegateEvent.js';\n\nimport { Cache } from './modules/Cache.js';\nimport { Classes } from './modules/Classes.js';\nimport { type Visit, createVisit } from './modules/Visit.js';\nimport { Hooks, type HookName, type HookInitOptions } from './modules/Hooks.js';\nimport { getAnchorElement } from './modules/getAnchorElement.js';\nimport { awaitAnimations } from './modules/awaitAnimations.js';\nimport { navigate, performNavigation, type NavigationToSelfAction } from './modules/navigate.js';\nimport { fetchPage } from './modules/fetchPage.js';\nimport { animatePageOut } from './modules/animatePageOut.js';\nimport { replaceContent } from './modules/replaceContent.js';\nimport { scrollToContent } from './modules/scrollToContent.js';\nimport { animatePageIn } from './modules/animatePageIn.js';\nimport { renderPage } from './modules/renderPage.js';\nimport { use, unuse, findPlugin, type Plugin } from './modules/plugins.js';\nimport { isSameResolvedUrl, resolveUrl } from './modules/resolveUrl.js';\nimport { nextTick } from './utils.js';\nimport { type HistoryState } from './helpers/history.js';\n\n/** Options for customizing swup's behavior. */\nexport type Options = {\n\t/** Whether history visits are animated. Default: `false` */\n\tanimateHistoryBrowsing: boolean;\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tanimationSelector: string | false;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tanimationScope: 'html' | 'containers';\n\t/** Enable in-memory page cache. Default: `true` */\n\tcache: boolean;\n\t/** Content containers to be replaced on page visits. Default: `['#swup']` */\n\tcontainers: string[];\n\t/** Callback for ignoring visits. Receives the element and event that triggered the visit. */\n\tignoreVisit: (url: string, { el, event }: { el?: Element; event?: Event }) => boolean;\n\t/** Selector for links that trigger visits. Default: `'a[href]'` */\n\tlinkSelector: string;\n\t/** How swup handles links to the same page. Default: `scroll` */\n\tlinkToSelf: NavigationToSelfAction;\n\t/** Enable native animations using the View Transitions API. */\n\tnative: boolean;\n\t/** Hook handlers to register. */\n\thooks: Partial<HookInitOptions>;\n\t/** Plugins to register on startup. */\n\tplugins: Plugin[];\n\t/** Custom headers sent along with fetch requests. */\n\trequestHeaders: Record<string, string>;\n\t/** Rewrite URLs before loading them. */\n\tresolveUrl: (url: string) => string;\n\t/** Callback for telling swup to ignore certain popstate events.  */\n\tskipPopStateHandling: (event: PopStateEvent) => boolean;\n\t/** Request timeout in milliseconds. */\n\ttimeout: number;\n};\n\nconst defaults: Options = {\n\tanimateHistoryBrowsing: false,\n\tanimationSelector: '[class*=\"transition-\"]',\n\tanimationScope: 'html',\n\tcache: true,\n\tcontainers: ['#swup'],\n\thooks: {},\n\tignoreVisit: (url, { el } = {}) => !!el?.closest('[data-no-swup]'),\n\tlinkSelector: 'a[href]',\n\tlinkToSelf: 'scroll',\n\tnative: false,\n\tplugins: [],\n\tresolveUrl: (url) => url,\n\trequestHeaders: {\n\t\t'X-Requested-With': 'swup',\n\t\t'Accept': 'text/html, application/xhtml+xml'\n\t},\n\tskipPopStateHandling: (event) => (event.state as HistoryState)?.source !== 'swup',\n\ttimeout: 0\n};\n\n/** Swup page transition library. */\nexport default class Swup {\n\t/** Library version */\n\treadonly version: string = version;\n\t/** Options passed into the instance */\n\toptions: Options;\n\t/** Default options before merging user options */\n\treadonly defaults: Options = defaults;\n\t/** Registered plugin instances */\n\tplugins: Plugin[] = [];\n\t/** Data about the current visit */\n\tvisit: Visit;\n\t/** Cache instance */\n\treadonly cache: Cache;\n\t/** Hook registry */\n\treadonly hooks: Hooks;\n\t/** Animation class manager */\n\treadonly classes: Classes;\n\t/** Location of the currently visible page */\n\tlocation: Location = Location.fromUrl(window.location.href);\n\t/** URL of the currently visible page @deprecated Use swup.location.url instead */\n\tget currentPageUrl(): string {\n\t\treturn this.location.url;\n\t}\n\t/** Index of the current history entry */\n\tprotected currentHistoryIndex: number;\n\t/** Delegated event subscription handle */\n\tprotected clickDelegate?: DelegateEventUnsubscribe;\n\t/** Navigation status */\n\tprotected navigating: boolean = false;\n\t/** Run anytime a visit ends */\n\tprotected onVisitEnd?: () => Promise<unknown>;\n\n\t/** Install a plugin */\n\tuse = use;\n\t/** Uninstall a plugin */\n\tunuse = unuse;\n\t/** Find a plugin by name or instance */\n\tfindPlugin = findPlugin;\n\n\t/** Log a message. Has no effect unless debug plugin is installed */\n\tlog: (message: string, context?: unknown) => void = () => {};\n\n\t/** Navigate to a new URL */\n\tnavigate = navigate;\n\t/** Actually perform a navigation */\n\tprotected performNavigation = performNavigation;\n\t/** Create a new context for this visit */\n\tprotected createVisit = createVisit;\n\t/** Register a delegated event listener */\n\tdelegateEvent = delegateEvent;\n\t/** Fetch a page from the server */\n\tfetchPage = fetchPage;\n\t/** Resolve when animations on the page finish */\n\tawaitAnimations = awaitAnimations;\n\tprotected renderPage = renderPage;\n\t/** Replace the content after page load */\n\treplaceContent = replaceContent;\n\tprotected animatePageIn = animatePageIn;\n\tprotected animatePageOut = animatePageOut;\n\tprotected scrollToContent = scrollToContent;\n\t/** Find the anchor element for a given hash */\n\tgetAnchorElement = getAnchorElement;\n\n\t/** Get the current page URL */\n\tgetCurrentUrl = getCurrentUrl;\n\t/** Resolve a URL to its final location */\n\tresolveUrl = resolveUrl;\n\t/** Check if two URLs resolve to the same location */\n\tprotected isSameResolvedUrl = isSameResolvedUrl;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\t// Merge defaults and options\n\t\tthis.options = { ...this.defaults, ...options };\n\n\t\tthis.handleLinkClick = this.handleLinkClick.bind(this);\n\t\tthis.handlePopState = this.handlePopState.bind(this);\n\n\t\tthis.cache = new Cache(this);\n\t\tthis.classes = new Classes(this);\n\t\tthis.hooks = new Hooks(this);\n\t\tthis.visit = this.createVisit({ to: '' });\n\n\t\tthis.currentHistoryIndex = (window.history.state as HistoryState)?.index ?? 1;\n\n\t\tthis.enable();\n\t}\n\n\t/** Enable this instance, adding listeners and classnames. */\n\tasync enable() {\n\t\t// Add event listener\n\t\tconst { linkSelector } = this.options;\n\t\tthis.clickDelegate = this.delegateEvent(linkSelector, 'click', this.handleLinkClick);\n\n\t\twindow.addEventListener('popstate', this.handlePopState);\n\n\t\t// Set scroll restoration to manual if animating history visits\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// Initial save to cache\n\t\tif (this.options.cache) {\n\t\t\t// Disabled to avoid caching modified dom state: logic moved to preload plugin\n\t\t\t// https://github.com/swup/swup/issues/475\n\t\t}\n\n\t\t// Sanitize/check native option\n\t\tthis.options.native = this.options.native && !!document.startViewTransition;\n\n\t\t// Mount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.use(plugin));\n\n\t\t// Install user hooks\n\t\tfor (const [key, handler] of Object.entries(this.options.hooks)) {\n\t\t\t// Build hook options from modifier suffix: 'content:replace.before' => { before: true }\n\t\t\tconst [hook, modifiers] = this.hooks.parseName(key as HookName);\n\t\t\t// @ts-expect-error: object.entries() does not preserve key/value types\n\t\t\tthis.hooks.on(hook, handler, modifiers);\n\t\t}\n\n\t\t// Create initial history record\n\t\tif ((window.history.state as HistoryState)?.source !== 'swup') {\n\t\t\tupdateHistoryRecord(null, { index: this.currentHistoryIndex });\n\t\t}\n\n\t\t// Give consumers a chance to hook into enable\n\t\tawait nextTick();\n\n\t\t// Trigger enable hook\n\t\tawait this.hooks.call('enable', undefined, undefined, () => {\n\t\t\tconst html = document.documentElement;\n\t\t\thtml.classList.add('swup-enabled');\n\t\t\thtml.classList.toggle('swup-native', this.options.native);\n\t\t});\n\t}\n\n\t/** Disable this instance, removing listeners and classnames. */\n\tasync destroy() {\n\t\t// remove delegated listener\n\t\tthis.clickDelegate!.destroy();\n\n\t\t// remove popstate listener\n\t\twindow.removeEventListener('popstate', this.handlePopState);\n\n\t\t// empty cache\n\t\tthis.cache.clear();\n\n\t\t// unmount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.unuse(plugin));\n\n\t\t// trigger disable hook\n\t\tawait this.hooks.call('disable', undefined, undefined, () => {\n\t\t\tconst html = document.documentElement;\n\t\t\thtml.classList.remove('swup-enabled');\n\t\t\thtml.classList.remove('swup-native');\n\t\t});\n\n\t\t// remove handlers\n\t\tthis.hooks.clear();\n\t}\n\n\t/** Determine if a visit should be ignored by swup, based on URL or trigger element. */\n\tshouldIgnoreVisit(href: string, { el, event }: { el?: Element; event?: Event } = {}) {\n\t\tconst { origin, url, hash } = Location.fromUrl(href);\n\n\t\t// Ignore if the new origin doesn't match the current one\n\t\tif (origin !== window.location.origin) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the link/form would open a new window (or none at all)\n\t\tif (el && this.triggerWillOpenNewWindow(el)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the visit should be ignored as per user options\n\t\tif (this.options.ignoreVisit(url + hash, { el, event })) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Finally, allow the visit\n\t\treturn false;\n\t}\n\n\tprotected handleLinkClick(event: DelegateEvent<MouseEvent>) {\n\t\tconst el = event.delegateTarget as HTMLAnchorElement;\n\t\tconst { href, url, hash } = Location.fromElement(el);\n\n\t\t// Exit early if the link should be ignored\n\t\tif (this.shouldIgnoreVisit(href, { el, event })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ignore if swup is currently navigating towards the link's URL\n\t\tif (this.navigating && url === this.visit.to.url) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tconst visit = this.createVisit({ to: url, hash, el, event });\n\n\t\t// Exit early if control key pressed\n\t\tif (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n\t\t\tthis.hooks.callSync('link:newtab', visit, { href });\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if other than left mouse button\n\t\tif (event.button !== 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hooks.callSync('link:click', visit, { el, event }, () => {\n\t\t\tconst from = visit.from.url ?? '';\n\n\t\t\tevent.preventDefault();\n\n\t\t\t// Handle links to the same page\n\t\t\tif (!url || url === from) {\n\t\t\t\tif (hash) {\n\t\t\t\t\t// With hash: scroll to anchor\n\t\t\t\t\tthis.hooks.callSync('link:anchor', visit, { hash }, () => {\n\t\t\t\t\t\tupdateHistoryRecord(url + hash);\n\t\t\t\t\t\tthis.scrollToContent(visit);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Without hash: scroll to top or load/reload page\n\t\t\t\t\tthis.hooks.callSync('link:self', visit, undefined, () => {\n\t\t\t\t\t\tif (this.options.linkToSelf === 'navigate') {\n\t\t\t\t\t\t\tthis.performNavigation(visit);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdateHistoryRecord(url);\n\t\t\t\t\t\t\tthis.scrollToContent(visit);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Exit early if the resolved path hasn't changed\n\t\t\tif (this.isSameResolvedUrl(url, from)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Finally, proceed with loading the page\n\t\t\tthis.performNavigation(visit);\n\t\t});\n\t}\n\n\tprotected handlePopState(event: PopStateEvent) {\n\t\tconst href: string = (event.state as HistoryState)?.url ?? window.location.href;\n\n\t\t// Exit early if this event should be ignored\n\t\tif (this.options.skipPopStateHandling(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if the resolved path hasn't changed\n\t\tif (this.isSameResolvedUrl(getCurrentUrl(), this.location.url)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { url, hash } = Location.fromUrl(href);\n\n\t\tconst visit = this.createVisit({ to: url, hash, event });\n\n\t\t// Mark as history visit\n\t\tvisit.history.popstate = true;\n\n\t\t// Determine direction of history visit\n\t\tconst index = (event.state as HistoryState)?.index ?? 0;\n\t\tif (index && index !== this.currentHistoryIndex) {\n\t\t\tconst direction = index - this.currentHistoryIndex > 0 ? 'forwards' : 'backwards';\n\t\t\tvisit.history.direction = direction;\n\t\t\tthis.currentHistoryIndex = index;\n\t\t}\n\n\t\t// Disable animation & scrolling for history visits\n\t\tvisit.animation.animate = false;\n\t\tvisit.scroll.reset = false;\n\t\tvisit.scroll.target = false;\n\n\t\t// Animated history visit: re-enable animation & scroll reset\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\tvisit.animation.animate = true;\n\t\t\tvisit.scroll.reset = true;\n\t\t}\n\n\t\tthis.hooks.callSync('history:popstate', visit, { event }, () => {\n\t\t\tthis.performNavigation(visit);\n\t\t});\n\t}\n\n\t/** Determine whether an element will open a new tab when clicking/activating. */\n\tprotected triggerWillOpenNewWindow(triggerEl: Element) {\n\t\tif (triggerEl.matches('[download], [target=\"_blank\"]')) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n"],"names":["ledger","WeakMap","editLedger","wanted","baseElement","callback","setup","has","elementMap","get","set","setups","Set","existed","add","delete","classify","text","fallback","String","toLowerCase","replace","getCurrentUrl","_temp","hash","window","location","pathname","search","updateHistoryRecord","url","data","state","history","random","Math","source","replaceState","delegateEvent","selector","type","options","controller","AbortController","signal","base","document","aborted","once","nativeListenerOptions","Document","documentElement","capture","Boolean","listenerFunction","event","delegateTarget","target","Text","parentElement","Element","currentTarget","closest","contains","safeClosest","Object","assign","call","removeEventListener","JSON","stringify","addEventListener","delegate","destroy","abort","Location","URL","constructor","baseURI","super","toString","setPrototypeOf","this","prototype","fromElement","el","href","getAttribute","fromUrl","fetchPage","_this","_temp2","_result","status","responseUrl","response","Promise","resolve","then","html","hooks","visit","FetchError","finalUrl","page","cache","write","method","headers","requestHeaders","timeout","timedOut","timeoutId","setTimeout","_ref","fetch","_this$hooks$call","clearTimeout","_catch","error","name","e","reject","Error","message","details","Cache","swup","pages","Map","size","all","copy","forEach","key","result","callSync","undefined","update","payload","clear","prune","predicate","urlToResolve","resolveUrl","query","context","querySelector","queryAll","Array","from","querySelectorAll","nextTick","requestAnimationFrame","isPromise","obj","getContextualAttr","attr","hasAttribute","Classes","swupClasses","selectors","scope","animation","containers","isArray","join","targets","trim","classList","slice","arguments","remove","className","split","filter","c","isSwupClass","some","startsWith","Visit","id","to","trigger","scroll","meta","animate","wait","native","animationScope","animationSelector","read","action","popstate","direction","reset","advance","done","createVisit","_iteratorSymbol","Symbol","iterator","pact","value","s","_Pact","o","_settle","bind","v","observer","onFulfilled","onRejected","thenable","Hooks","registry","init","hook","create","exists","console","on","handler","warn","registration","off","before","arg1","arg2","arg3","args","defaultHandler","parseCallArgs","after","getHandlers","run","dispatchDomEvent","runSync","registrations","rethrow","_exit","_this2","results","body","check","step","_cycle","next","return","_fixup","TypeError","i","length","push","array","_isSettledPact","_forTo","values","_forOf","_ref2","func","runAsPromise","_result2","found","replaced","sort","sortRegistrations","_ref3","_ref4","T","_ref5","index","replacingHandler","createDefaultHandler","a","b","priority","detail","dispatchEvent","CustomEvent","bubbles","parseName","modifiers","reduce","acc","mod","getAnchorElement","charAt","substring","decoded","decodeURIComponent","element","getElementById","CSS","escape","awaitAnimations","elements","animatedElements","awaitedAnimations","map","propCount","styles","getComputedStyle","transitionDelays","getStyleProperties","TRANSITION","transitionDurations","transitionTimeout","calculateTimeout","animationDelays","ANIMATION","animationDurations","animationTimeout","max","getTransitionInfo","endEvent","startTime","performance","now","propsTransitioned","end","onEnd","elapsedTime","awaitAnimationsOnElement","delays","durations","concat","duration","toMs","time","parseFloat","performNavigation","_temp4","navigating","referrer","classes","includes","_exit2","_temp8","_result4","animatePageOut","_temp6","animatePageIn","_temp5","startViewTransition","_renderPage3","renderPage","_page3","finished","_renderPage2","_page2","_temp7","_renderPage","_page","onVisitEnd","_temp9","_this$fetchPage","cachedPage","DOMParser","parseFromString","newUrl","currentHistoryIndex","pushState","createHistoryRecord","skipPopStateHandling","back","_finallyRethrows","_wasThrown","_result3","_temp3","navigate","shouldIgnoreVisit","skip","replaceContent","incomingDocument","title","innerText","persistedElements","currentEl","incomingEl","replaceWith","cloneNode","existing","replacement","scrollToContent","behavior","scrollTarget","scrolled","anchor","scrollIntoView","scrollTo","top","left","isSameResolvedUrl","use","plugin","maybeInvalidPlugin","isSwupPlugin","_checkRequirements","_beforeMount","mount","plugins","unuse","pluginOrName","findPlugin","unmount","_afterUnmount","p","find","url1","url2","defaults","animateHistoryBrowsing","ignoreVisit","linkSelector","linkToSelf","Accept","currentPageUrl","version","clickDelegate","log","handleLinkClick","handlePopState","enable","scrollRestoration","entries","toggle","origin","triggerWillOpenNewWindow","preventDefault","metaKey","ctrlKey","shiftKey","altKey","button","triggerEl","matches"],"mappings":"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"}